{
    "data":{
        "slug": "",
        "code": "",
        "topic": "Merging two sorted linked lists",
        "description": "You are given 2 lists of integers, both the lists are sorted in increasing order. You have to merge both the lists, such that the final list also have to be sorted in increasing order.\n",
        "example": "> For Example:\n1. Let \"A= {5, 10, 15}\" and \"B= {2, 3, 20}\"\nThen Output= \"{2, 3, 5, 10, 15, 20}\"\n\n2. Let \"A= {5, 10, 15}\" and B= {}\nThen Output= \"{5, 10, 15}\"\n\n3. Let A= {} and \"B= {2, 3, 20}\"\nThen Output= \"{2, 3, 20}\"\n\n4. Let A= {} and B= {}\nThen Output= {}\n\n",
        "solutions": [
            {
				"topic": "Method 1: Using Dummy Nodes",
				"description": "The idea is to use a dummy node to make the final sorted list. Initially the dummy node is the starting node and its tail is pointing nowhere. One by one the smaller node from the lists A and B will be removed and added to the tail of the final list.\n",
				"algorithm": "#let the sorted lists be\nA={5, 10, 15}\nB={2, 3, 20}\n\n#introduce dummy node in final list\nNode dummy;\nNode* tail= &dummy;\n#initially no node in final list except dummy node\ndummy.next= NULL;\n\n#process of adding nodes from lists A and B in final list\nwhile(true)\nif(A==NULL)\n#if there are no more nodes in A then add all the nodes of B\nto the final list\ntail.next=B;\nend-if\nelse if(B==NULL)\n#if there are no more nodes in B then add all the nodes of A\nto the final list\ntail.next=A;\nend-else if\nif(A.data<=B.data)\n#places nodes from front of list A to the final list\nPlaceNode(&(tail.next), &A)\nend-if\nelse if(B.data<=A.data)\n#places nodes from front of list B to the final list\nPlaceNode(&(tail.next), &A)\nend-else if\nreturn dummy.next\n\n"
				"code": [
					{
						"language": "c",
						"code": "#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\n/* Node of a list*/\nstruct Node\n{\nint data;\nstruct Node* next;\n};\n/* Remove the front node of the source list and place it in final list */\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef);\n/* Takes two lists sorted in increasing order, and merge their nodes\ntogether to make one sorted list which is returned. */\nstruct Node* Merge(struct Node* a, struct Node* b)\n{\n/* a first dummy node to add remaining nodes */\nstruct Node dummy;\n/* tail points to the last result node */\nstruct Node* tail = &dummy;\n/* so tail->next is the place to add new nodes to the result. */\ndummy.next = NULL;\nwhile (1)\n{\nif (a == NULL)\n{\n/* if either list runs out, use the other list */\ntail->next = b;\nbreak;\n}\nelse if (b == NULL)\n{\ntail->next = a;\nbreak;\n}\nif (a->data <= b->data)\nPlaceNode(&(tail->next), &a);\nelse\nPlaceNode(&(tail->next), &b);\ntail = tail->next;\n}\nreturn(dummy.next);\n}\n/* UTILITY FUNCTIONS */\n/* PlaceNode() function takes the node from the front of the source list,\nand move it to the front of the final list.*/\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef)\n{\n/* the front source node */\nstruct Node* newNode = *sourceRef;\nassert(newNode != NULL);\n/* Advance the source pointer */\n*sourceRef = newNode->next;\n/* Link the old dest off the new node */\nnewNode->next = *destRef;\n/* Move dest to point to the new node */\n*destRef = newNode;\n}\n/* Function to insert a node at the beginging of the list */\nvoid add(struct Node** head_ref, int new_data)\n{\n/* allocate node */\nstruct Node* new_node =\n(struct Node*) malloc(sizeof(struct Node));\n/* put in the data */\nnew_node->data = new_data;\n/* link the old list off the new node */\nnew_node->next = (*head_ref);\n/* move the head to point to the new node */\n(*head_ref) = new_node;\n}\n/* Function to print nodes of a given list */\nvoid printList(struct Node *node)\n{\nwhile (node!=NULL)\n{\nprintf(\"%d \", node->data);\nnode = node->next;\n}\n}\nint main()\n{\n/* Start with the empty list */\nstruct Node* res = NULL;\nstruct Node* a = NULL;\nstruct Node* b = NULL;\n/* source lists*/\nadd(&a, 15);\nadd(&a, 10);\nadd(&a, 5);\nadd(&b, 20);\nadd(&b, 3);\nadd(&b, 2);\n/* Remove duplicates from linked list */\nres = Merge(a, b);\nprintf(\"Merged Linked List is: \\n\");\nprintList(res);\nreturn 0;\n}"
                    }
				],
				"complexity" : ">Time Complexity: __O(n)__ for traversing the list.\nSpace Complexity: __O(1)__ no extra space used\n"
            },
            {
              	"topic": "Method 2 : Using reference to the last node",
                "description": "The idea is to use a reference pointer which always points to the last node of the final list. Instead of using dummy node, the reference of the last node of final list is maintained by a pointer.\n",
                "algorithm": "#let the sorted lists be\nA={5, 10, 15}\nB={2, 3, 20}\n#introduce the final list\nNode* result = NULL;\n#pointer which maintains reference to the last node\nNode** lastPtrRef = &result;\n#process of adding nodes from lists A and B in final list\nWhile(true)\nif(A==NULL)\n#if there are no more nodes in A then lastPtrRef points to\nall the nodes of B for the final list\n*lastPtrRef = B;\nend-if\nelse if(B==NULL)\n#if there are no more nodes in B then lastPtrRef points to\nall the nodes of A for the final list\n*lastPtrRef = A;\nend-else if\nif(A.data<=B.data)\n#places nodes from front of list A to the final list\nPlaceNode(&(tail.next), &A);\nend-if\nelse if(B.data<=A.data)\n#places nodes from front of list B to the final list\nPlaceNode(&(tail.next), &A);\nend-else if\n#advancing the next field\nlastPtrRef = &((*lastPtrRef)->next);\nreturn result\n\n",
                "code": [
                {
                "language": "c",
                "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\n/* Node of a list*/\nstruct Node\n{\nint data;\nstruct Node* next;\n};\n/* Remove the front node of the source list and place it in final list */\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef);\n/* Takes two lists sorted in increasing order, and merge their nodes\ntogether to make one sorted list which is returned. */\nstruct Node* Merge(struct Node* a, struct Node* b)\n{\nstruct Node* result = NULL;\n/* point to the last result pointer */\nstruct Node** lastPtrRef = &result;\nwhile(1)\n{\nif (a == NULL)\n{\n*lastPtrRef = b;\nbreak;\n}\nelse if (b==NULL)\n{\n*lastPtrRef = a;\nbreak;\n}\nif(a->data <= b->data)\n{\nMoveNode(lastPtrRef, &a);\n}\nelse\n{\nMoveNode(lastPtrRef, &b);\n}\n/*advance to point to the next \".next\" field */\nlastPtrRef = &((*lastPtrRef)->next);\n}\nreturn(result);\n}\n/* UTILITY FUNCTIONS */\n/* PlaceNode() function takes the node from the front of the source list,\nand move it to the front of the final list.*/\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef)\n{\n/* the front source node */\nstruct Node* newNode = *sourceRef;\nassert(newNode != NULL);\n/* Advance the source pointer */\n*sourceRef = newNode->next;\n/* Link the old dest off the new node */\nnewNode->next = *destRef;\n/* Move dest to point to the new node */\n*destRef = newNode;\n}\n/* Function to insert a node at the beginging of the list */\nvoid add(struct Node** head_ref, int new_data)\n{\n/* allocate node */\nstruct Node* new_node =\n(struct Node*) malloc(sizeof(struct Node));\n/* put in the data */\nnew_node->data = new_data;\n/* link the old list off the new node */\nnew_node->next = (*head_ref);\n/* move the head to point to the new node */\n(*head_ref) = new_node;\n}\n/* Function to print nodes of a given list */\nvoid printList(struct Node *node)\n{\nwhile (node!=NULL)\n{\nprintf(\"%d \", node->data);\nnode = node->next;\n}\n}\nint main()\n{\n/* Start with the empty list */\nstruct Node* res = NULL;\nstruct Node* a = NULL;\nstruct Node* b = NULL;\n/* source lists*/\nadd(&a, 15);\nadd(&a, 10);\nadd(&a, 5);\nadd(&b, 20);\nadd(&b, 3);\nadd(&b, 2);\n/* Remove duplicates from linked list */\nres = Merge(a, b);\nprintf(\"Merged Linked List is: \\n\");\nprintList(res);\nreturn 0;\n}"
                }
                ],
                "complexity": ">Time Complexity: __O(n)__ for traversing the list.\nSpace Complexity: __O(1)__ no extra space used\n"
            },
            {
                "topic": "Method 3 : Using Recursion",
                "description": "The idea is to use the function which adds the node to the final list recursively.\n",
                "algorithm": "#let the sorted lists be\nA={5, 10, 15}\nB={2, 3, 20}\n#Merging two lists in sorted increasing order\nMerge(Node* A, Node* B)\n#introduce the final list\nNode* result = NULL;\n#process of adding nodes from lists A and B in final list\nif(A==NULL)\n#if there are no more nodes in A then add all the nodes of B to the\nfinal list\nreturn(B);\nend-if\nelse if(B==NULL)\n#if there are no more nodes in B then add all the nodes of A to the\nfinal list\nreturn(A);\nend-else if\nif(A.data<=B.data)\n#places nodes from front of list A to the final list\nresult = a;\nresult->next = Merge(a->next, b);\nend-if\nelse if(B.data<=A.data)\n#places nodes from front of list B to the final list\nresult = b;\nresult->next = Merge(b->next, a);\nend-else if\nreturn result\n\n",
                "code": [
                {
                "language": "c",
                "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\n/* Node of a list*/\nstruct Node\n{\nint data;\nstruct Node* next;\n};\n/* Remove the front node of the source list and place it in final list */\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef);\n/* Takes two lists sorted in increasing order, and merge their nodes\ntogether to make one sorted list which is returned. */\nstruct Node* Merge(struct Node* a, struct Node* b)\n{\nstruct Node* result = NULL;\n/* Base cases */\nif (a == NULL)\nreturn(b);\nelse if (b==NULL)\nreturn(a);\n/* Pick either a or b, and recur */\nif (a->data <= b->data)\n{\nresult = a;\nresult->next = SortedMerge(a->next, b);\n}\nelse\n{\nresult = b;\nresult->next = SortedMerge(a, b->next);\n}\nreturn(result);\n}\n/* UTILITY FUNCTIONS */\n/* PlaceNode() function takes the node from the front of the source list,\nand move it to the front of the final list.*/\nvoid PlaceNode(struct Node** destRef, struct Node** sourceRef)\n{\n/* the front source node */\nstruct Node* newNode = *sourceRef;\nassert(newNode != NULL);\n/* Advance the source pointer */\n*sourceRef = newNode->next;\n/* Link the old dest off the new node */\nnewNode->next = *destRef;\n/* Move dest to point to the new node */\n*destRef = newNode;\n}\n/* Function to insert a node at the beginging of the list */\nvoid add(struct Node** head_ref, int new_data)\n{\n/* allocate node */\nstruct Node* new_node =\n(struct Node*) malloc(sizeof(struct Node));\n/* put in the data */\nnew_node->data = new_data;\n/* link the old list off the new node */\nnew_node->next = (*head_ref);\n/* move the head to point to the new node */\n(*head_ref) = new_node;\n}\n/* Function to print nodes of a given list */\nvoid printList(struct Node *node)\n{\nwhile (node!=NULL)\n{\nprintf(\"%d \", node->data);\nnode = node->next;\n}\n}\nint main()\n{\n/* Start with the empty list */\nstruct Node* res = NULL;\nstruct Node* a = NULL;\nstruct Node* b = NULL;\n/* source lists*/\nadd(&a, 15);\nadd(&a, 10);\nadd(&a, 5);\nadd(&b, 20);\nadd(&b, 3);\nadd(&b, 2);\n/* Remove duplicates from linked list */\nres = Merge(a, b);\nprintf(\"Merged Linked List is: \\n\");\nprintList(res);\nreturn 0;\n}"
                }
                ],
                "complexity": ">Time Complexity is __O(n)__ for traversing the list.\nSpace Complexity is __O(n)__ as stack is used\n"
            }

        ]
    }
}
